
from experiment.agent_exp import TestingFramework
from agent.action import *
from pathlib import Path
from tqdm import tqdm
import json, os, copy, re
from typing import Union, Dict, List
from collections import deque
from pydantic import ValidationError
import logging
import jsonlines
import sys
import re
import copy

def fetch_args(args_lookup, logic_exp):
    out = copy.deepcopy(logic_exp)
    assert 'steps' in logic_exp.keys()
    for s, step in enumerate(logic_exp['steps']):
        if isinstance(step, int):
            out['steps'][s] = args_lookup[step]
        elif isinstance(step, dict):
            out['steps'][s] = fetch_args(args_lookup, step)
    return out


def plan_to_args(plan, keyword='Step'):
    """
    Convert a plan text to a structured dictionary with steps.

    Args:
        plan (str): Plan in text format.
        keyword (str): Keyword prefix for steps (default: "Step").

    Returns:
        dict: Structured plan with steps as a list.
    """
    args = []
    lines = plan.split('\n')
    for line in lines:
        if line.startswith(keyword):
            args.append(re.sub(r'{} \d+: '.format(keyword), '', line))

    return {'steps': args}  # Only return the steps, no logic


def parse_expression(expression):
    """
    Parse a logical expression to extract step relationships.

    Args:
        expression (str): Logical expression containing steps.

    Returns:
        dict: Parsed logical structure with steps and relationships.
    """
    stack = []
    current = {}
    for token in re.findall(r'Step \d+|AND|OR|\(|\)', expression):
        if token.startswith('Step'):
            if 'steps' not in current:
                current['steps'] = []
            current['steps'].append(int(token.split()[1]))
        elif token in ('AND', 'OR'):
            current['logic'] = token
        elif token == '(':
            stack.append(current)
            current = {}
        elif token == ')':
            closed = current
            current = stack.pop()
            if 'steps' not in current:
                current['steps'] = []
            current['steps'].append(closed)
    return current

plan_prompt = '''
Your task is to come up with a short plan to help me accomplish my goal in a couple of steps using at most ONE of the provided crafting commands. You can take the help of crafting commands below to create new objects. 
Craft command can be understood as follows: craft [target] using [ingredients], where target is item/object generated by the craft command as output and ingredient are the inputs. You are given an agent that can "craft" or "fetch" objects.

Here is are some examples.

Crafting commands:
craft 3 dark oak sign using 6 dark oak planks, 1 stick
craft 4 dark oak planks using 1 dark oak log
craft 1 stick using 1 planks
craft 4 stick using 2 bamboo
craft 4 oak planks using 1 oak log
craft 1 dark oak fence using 2 stick, 4 dark oak planks
craft 1 warped stairs using 6 warped planks
craft 3 oak sign using 6 oak planks, 1 stick

## Example1
Goal: craft dark oak sign.
### Plan
# Think: To craft a dark oak sign, I need 6 dark oak planks and 1 stick. 
# I will collect the required resources step by step and then craft the dark oak sign.
# Think: My target is 6 dark oak planks. From the crafting commands, I can use:
# craft 4 dark oak planks using 1 dark oak log. To achieve this, I need to fetch 2 dark oak logs and craft the planks.
Step 1: fetch 2 dark oak logs
# Think: Now that I have 2 dark oak logs, I will craft 8 dark oak planks using the recipe.
Step 2: craft 4 dark oak planks using 1 dark oak log (repeat twice)
# Think: My target is 1 stick. From the crafting commands, I can use:
# craft 1 stick using 1 plank. To achieve this, I need to fetch a plank and craft the stick.
Step 3: fetch 1 plank
Step 4: craft 1 stick using 1 plank
# Think: Finally, I have 6 dark oak planks and 1 stick. I can craft the dark oak sign using the final recipe.
Step 5: craft dark oak sign using 6 dark oak planks, 1 stick

## Example2
Goal: craft dark oak fence.
### Plan
# Think: To craft a dark oak fence, I need 4 dark oak planks and 2 sticks.
# I will collect the required resources step by step and then craft the dark oak fence.
# Think: My target is 4 dark oak planks. From the crafting commands, I can use:
# craft 4 dark oak planks using 1 dark oak log. To achieve this, I need to fetch a dark oak log first.
Step 1: fetch 1 dark oak log
# Think: Now that I have 1 dark oak log, I can craft 4 dark oak planks using the available recipe.
Step 2: craft 4 dark oak planks using 1 dark oak log
# Think: My target is 2 sticks. From the crafting commands, I can use:
# craft 4 stick using 2 bamboo. To achieve this, I need to fetch bamboo first.
Step 3: fetch 2 bamboo
# Think: Now that I have 2 bamboo, I can craft 4 sticks using the available recipe.
Step 4: craft 4 stick using 2 bamboo
# Think: Finally, I have 4 dark oak planks and 2 sticks. I can craft the dark oak fence using the final recipe.
Step 5: craft 1 dark oak fence using 2 stick, 4 dark oak planks

Crafting commands:
craft 6 polished blackstone slab using 3 polished blackstone
craft 1 polished blackstone pressure plate using 2 polished blackstone
craft 4 polished blackstone stairs using 6 polished blackstone
craft 1 polished blackstone button using 1 polished blackstone
craft 6 blackstone wall using 6 blackstone
craft 4 polished blackstone using 4 blackstone
craft 4 blackstone stairs using 6 blackstone
craft 4 polished blackstone bricks using 4 polished blackstone
craft 6 blackstone slab using 3 blackstone
craft 6 polished blackstone wall using 6 polished blackstone

## Example1
Goal: craft polished blackstone slab.
## Plan
# Think: To craft polished blackstone slab, I need 3 polished blackstone. From the crafting commands, I can craft 4 polished blackstone using 4 blackstone. I will collect the required resources step by step and then craft the polished blackstone slab.
# Think: My target is 4 blackstone. I need to fetch the blackstone from the environment.
Step 1: Fetch 4 blackstone.
# Think: Now that I have 4 blackstone, I will craft 4 polished blackstone using the recipe.
Step 2: Craft 4 polished blackstone using 4 blackstone.
# Think: Finally, I have enough polished blackstone to craft polished blackstone slab. Using the recipe, I will craft the slab.
# Step 3: Craft 6 polished blackstone slab using 3 polished blackstone.

## Example2
Goal: craft polished blackstone wall.
## Plan
# Think: To craft a polished blackstone wall, I need 6 polished blackstone. From the crafting commands, I can craft 4 polished blackstone using 4 blackstone. To get enough polished blackstone, I will collect blackstone and craft the polished blackstone step by step.
# Think: My target is 8 blackstone to craft 8 polished blackstone (using two crafting recipes).
Step 1: Fetch 8 blackstone.
# Think: Now that I have 8 blackstone, I will craft 8 polished blackstone using the recipe.
Step 2: Craft 4 polished blackstone using 4 blackstone (repeat twice).
# Think: Finally, I have enough polished blackstone to craft a polished blackstone wall. Using the recipe, I will craft the wall.
Step 3: Craft 6 polished blackstone wall using 6 polished blackstone.



Here is a different goal with different craft commands. Your task is to come up with a short plan to help me accomplish my goal in a couple of steps using at most ONE of the provided crafting commands. You can take the help of crafting commands below to create new objects. Keep in mind that:
- It is okay to generate more target objects than your goal.
- Be very careful with the count of objects, SAME object counts mentioned in the input crafting command. 
- You cannot use a partial crafting command recipe, i.e. if the recipe generates 2 objects you CANNOT alter it to produce just 1. 

'''


class MinecraftFramework(TestingFramework):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
            
    def plan_llm(self, prompt):
        
        prompt = prompt
        sys_prompt = "You are an helpful assistant helping me play a simple version of Minecraft.'"
        messages = [
            self.encoded_message(sys_prompt, "system"),
            self.encoded_message(plan_prompt + "\n" + prompt, "user")
        ]
        
        response = self.get_response(messages)
        
        return response
    
    
    def get_plan(self, task, max_attempts=3):
        """
        Generate a plan for a given task using LLM, with retry mechanism.

        Args:
            task (str): The specific task to accomplish.
            
            prompt_template (str): Template for prompting the LLM to generate a plan.
            max_attempts (int): Maximum number of retry attempts.
            verbose (bool): If True, prints detailed logs.

        Returns:
            dict: Parsed plan with steps and logic (e.g., {"steps": [...], "logic": "AND"}).
        """
        custom_prompt = task
        
        for attempt in range(max_attempts):
            try:
                logging.info(f"Attempt {attempt + 1}: Generating plan with LLM...")
                # Call the LLM to generate a plan
                plan_text = self.plan_llm(custom_prompt)
                logging.info(f"Plan generated by LLM:\n{plan_text}")
                # Parse the plan text into a structured format
                plan = plan_to_args(plan_text)
                if not plan["steps"]:
                    continue
                logging.info(f"Parsed Plan:\n{plan}")
                return plan
            except Exception as e:
                logging.info(f"Error in attempt {attempt + 1} while generating or parsing the plan: {e}")
        
        # If all attempts fail, return a default empty plan
        logging.info(f"Failed to generate a valid plan after {max_attempts} attempts. Returning default plan.")
        return {"steps": [task]}
    
    def update_inventory(self):
        
        action = NotebookBlock(argument={"code": "check_inventory()"})
        result, _ = self.env.notebookblock(action)
        result = f"Observation: {result}"
        self.env.notebook.delete_block(len(self.env.notebook.notebook.cells) - 1)
        
        return action, result
    
    def execute_plan(self, plan):
        """
        Execute a given plan in the environment based on AND/OR logic.

        Args:
            plan (dict): The parsed plan, including steps and logic.
          
        Returns:
            tuple: (success, info_prop, action_checkpoint, step_results)
                - success (bool): Whether the plan execution was successful.
                - info_prop (str): Updated environmental state or inventory.
                - action_checkpoint (list): Updated list of executed actions.
                - step_results (list): Results of each step execution (e.g., success/failure).
        """
        
        action_checkpoint = []
        obs_checkpoint = []
        steps = plan.get("steps", [])
        
        logging.info(f"Executing plan: {plan}")

        step_results = []
        prompt = ""
        for step in steps:
            logging.info(f"Executing step: {step}")
            
            # Execute the step using the environment and LLM
            success, action_history, obs_history, result = self.execute_step(
                step, prompt)
            step_results.append({"step": step, "success": success, "result": result})

            # Handle AND logic: any step failure causes plan failure
            if not success:
                logging.info(f"Step failed (AND logic): {step}")
                return False,  step_results
            
            action_inventory, obs = self.update_inventory()
            action_history.append(action_inventory)
            obs_history.append(obs)
            prompt += f"Goal: {step}\n"
            for action, obs in zip(action_history, obs_history):
                prompt += f"Action: {action.print_action()}\n"
                prompt += f"{obs}\n"
            action_checkpoint.extend(action_history)
            obs_checkpoint.extend(obs_history)
            
        # If we complete all steps for AND, or none succeed for OR
        overall_success = True
        logging.info(f"Plan execution completed.")
        return overall_success, step_results
    
    def execute_step(self, step, prompt, max_attempts=10):
        """
        Execute a single step in the environment as a multi-step process.
        Args:
            step (str): The step to execute.
            env: The environment to interact with.
            prompt (str): The LLM prompt to guide action generation.
            info_prop (str): Current environmental state or inventory.
            action_checkpoint (list): Actions executed so far.
            max_attempts (int): Maximum number of attempts to execute the step.
            verbose (bool): Whether to print detailed logs.

        Returns:
            tuple: (success, updated_info_prop, updated_action_checkpoint)
        """
        
        action_history = []
        obs_history = []
        done = False
        result = ""
        step_idx, retry_count = 0, 0
       
        repeat_action = 0
        finished = False
        logging.info("Sovling Loop Begin")
        failed_action = 0
        
        obs = f"Here’s a summary of the steps you’ve completed so far:\n{prompt}\nNow, please proceed to tackle the current goal."
        step = f"Goal: {step}"
        
        logging.info(f"Step: {step}")
        
        while step_idx < max_attempts:
            logging.info(f"Solving Loop: Step {step_idx + 1} SolvingAgent: {obs}")

            res, action = self.agent.generate(step, obs)
            
            logging.info(f"Solving Loop: Step {step_idx + 1} SolvingAgent response: {res}")
            if action is None:
                logging.error("Failed to parse action from response.")
                if retry_count >= 3:
                    logging.error(f"Failed to extract the action {retry_count} consecutive times. Stop...")
                    return False, action_history, obs_history, None
                retry_count += 1
                obs = "Failed to parse action from your response, please make sure you provide a valid action from the Action Space"
                continue
            else:             
                obs, done = self.step(action)
                obs = f"Observation: {obs}"
   
            if done:
                failed_action = 0
                action_history.append(action)
                obs_history.append(obs)
                if isinstance(action, Terminate):
                    result = action.argument["result"]
                    logging.info("The task is done.")
                    finished = True
                    break
            else:
                failed_action += 1
                if failed_action >= 3:
                    return False, action_history, obs_history, None
                continue
            step_idx += 1
            
        return finished, action_history, obs_history, result
    
    def run(self, task: Dict, **kwargs):
        commmands = kwargs.get("commands")
        query = kwargs.get("query")
        solving_sys_prompt = kwargs.get(
            "solving_sys_prompt", 
            f"experiment/{self.task_type}/prompt_lib/prompt_CREATOR_decision.txt" if self.mode == "pipeline" \
                else f"expirement/{self.task_type}/prompt_lib/prompt_solving.txt" 
        )
    

        retrieval_sys_prompt =  kwargs.get(
            "retrieval_sys_prompt", 
            f"experiment/{self.task_type}/prompt_lib/prompt_retrieval.txt"
        )
        
        import shutil
        shutil.rmtree(self.tmp_dir)
        os.makedirs(self.tmp_dir, exist_ok=True)
        
        task = self.load_task(task)

        
        # Initialize variables
        retrieval_tools, tool_results, examples, decision_examples = [], "", "", ""
        
        # Retrieve APIs if not in primitive mode
        if not self.primitive:
            logging.info("Retrieving APIs...")
            retrieval_tools, tool_results, examples, decision_examples = self.retrieve(task, retrieval_sys_prompt)
        
        with open(solving_sys_prompt, 'r') as f:
                sys_prompt = f.read()
        sys_prompt = sys_prompt.replace("===api===", tool_results)
        sys_prompt = sys_prompt.replace("===example===", examples)
        sys_prompt = sys_prompt.replace("===commands===", commmands)
        
        if self.mode == "pipeline":
            logging.info("Generating tools in pipeline mode...")
            # Generate tool code
            plan = self.get_plan(task)
            self.agent.system_prompt = sys_prompt
            succ, result = self.execute_plan(plan)
            if not succ:
                return retrieval_tools, ""
        else:  # Standard mode
            logging.info("Executing in standard mode...")
            sys_prompt = sys_prompt.replace("===task===", task)
            self.agent.system_prompt = sys_prompt
            logging.info(f"System Prompt:\n{sys_prompt}")
            # Generate tool code
            solving_obs = "Let’s think step by step and focus on solving the task. Currently, your inventory is not carrying anything."
            result, finished = self.solving_loop(task, solving_obs)
            if not finished:
                return retrieval_tools, ""
            
        return (retrieval_tools, result)
    
    def test(self, tasks: Union[Dict,List[Dict]], output_path: str, **kwargs):
        if not output_path.endswith(".jsonl"):
            raise ValueError("Output file should be JSONL format.")
        if not os.path.exists(output_path):
            open(output_path, 'w').close()
        tasks = tasks if isinstance(tasks, list) else [tasks]
        for task in tasks:
            result = {}
            result.update(task)
            question = task["question"]
            commands = task["commands"]
            query = task["query"]
            kwargs["commands"] = commands
            kwargs["query"] = query
            logging.info(f"Question: {question}")
            std_answer = task["answer"]
            result.pop("answer", "")
            result["retrieved_api"] = []

            retrieval_tools, llm_answer = self.run(task, **kwargs)
            for tool in retrieval_tools:
                result["retrieved_api"].append(tool["name"])
                
            result["std_answer"] = task["answer"]
            result["llm_answer"] = llm_answer
            
            is_right = self.check_is_answer_right(task,gt_answer=std_answer, pre_answer="")
            result["success"] = True if is_right else False
            
            result_file = os.path.join(self.output_dir, f"{result['id']}.ipynb")
            if is_right:
                logging.info("~~~~~Correct Answer~~~~~")
            else:
                logging.info("~~~~~Wrong Answer~~~~~")
            self.env.notebook.save_notebook(result_file)
            self.env.clear_env()
            self.agent.clear()
            with jsonlines.open(output_path, "a") as f:
                f.write(result)
                
    def solving_loop(self, task, obs, **kwargs):

        solving_steps = kwargs.get("solving_steps", 15)
        self.agent.memory.clear_memory()
        
        done = False
        result = ""
        step_idx, retry_count = 0, 0
        finished = False
        logging.info("Sovling Loop Begin")
        failed_action = 0
        while step_idx < solving_steps:
            _, env_items = self.update_inventory()
            env_items = env_items.replace("Observation: ", "")
            logging.info(f"Current Inventory: {env_items}")
            logging.info(f"Solving Loop: Step {step_idx + 1} SolvingAgent: {obs}")
           
            res, action = self.agent.generate(task, obs, extra_msg={"inventory": env_items})
            logging.info(f"Solving Loop: Step {step_idx + 1} SolvingAgent response: {res}")
            if action is None:
                logging.error("Failed to parse action from response.")
                if retry_count >= 3:
                    logging.error(f"Failed to extract the action {retry_count} consecutive times. Stop...")
                    return None, False
                retry_count += 1
                obs = "Failed to parse action from your response, please make sure you provide a valid action."
                continue
            else:
                
                # Execute Action
                obs, done = self.step(action)
                obs = f"Observation: {obs}"
            if done:
                failed_action = 0
                if isinstance(action, Terminate):
                    result = action.argument["result"]
                    logging.info("The task is done.")
                    finished = True
                    break
            else:
                failed_action += 1
                if failed_action >= 3:
                    return None, False
                continue
            step_idx += 1
            
        return result, finished
    
    def load_task(self, task: Dict):
        commands = task["commands"]
        query = task["query"]
        import shutil
        prompt = (
            commands,
            f"\nGoal: {query}"
        )
        prompt = ''.join(prompt)
        open(Path(self.tmp_dir) / "tmp0.py", 'w').close()
        open(Path(self.tmp_dir) / "temp_tools.py", "w").close()
        with open(Path(self.tmp_dir) / "tools.py", "w") as f:
            src = open(Path(self.toolkit_path) / "tools.py", 'r')
            f.write(src.read())
            src.close()
        os.makedirs(Path(self.tmp_dir, "textcraft"), exist_ok=True)
        shutil.copytree(Path(self.toolkit_path, "textcraft"), Path(self.tmp_dir, "textcraft"), dirs_exist_ok=True)
        return prompt